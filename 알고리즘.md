# 알고리즘

> 좋은 개발자란 많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력 즉, 문제 해결 능력이 뛰어난 개발자를 말한다. 알고리즘은 문제 해결 기술을 연마하기 가장 좋은 방법이며 스스로 문제를 어떤 방식으로 해결하는지 의식하고 어느 부분이 부족한지, 어떤 부분을 개선해야 하는지 파악해야 한다.

1. Brute Force란?

- 컴퓨터의 빠른 계산 능력을 이용해 가능한 경우의 수를 일일이 나열하면서 답을 찾는 방법

2. Divide & Conquer란?

- 주어진 문제를 둘 이상의 부분 문제로 나눈 뒤, 각 문제에 대한 답을 재귀 호출을 통해 계산하고, 각 부분 문제의 답으로부터 전체 문제의 답을 계산하는 방법

3. Dynamic Programming이란?

- 큰 의미에서는 분할 정복과 같은 접근 방식으로, 여러번 중복되는 부분 문제의 계산 결과를 저장하고 결과를 재활용하여 속도를 향상시키는 방법

4. Greedy란?

- 각 단계마다 지금 당장 가장 좋은 방법만 선택하는 방법으로, 지금의 선택이 앞으로 남은 선택들에 어떤 영향을 끼칠지는 고려하지 않음

5. Memoization이란?

- 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술

6. Binary Search란?

- 원하는 탐색 범위를 두 부분으로 분할하여 탐색하는 방법
- O(logn)

7. BFS(Breath-First Search)란?

- 그래프 탐색의 일종으로 너비 우선 탐색
- 루트 노드에서 시작해 인접한 노드를 먼저 탐색하는 방법
- 깊게 보단 넓게 탐색하는 방법
- 큐를 이용해 구현

8. DFS(Depth-First Search)란?

- 그래프 탐색의 일종으로 깊이 우선 탐색
- 루트 노드에서 시작해 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법
- 넓게 보단 깊게 탐색하는 방법
- 스택을 이용해 구현

9. Backtracking이란?

- 모든 경우의 수를 상태 공간 트리(State Space Tree)를 통해 표현하며 해를 찾아가는 도중, 지금의 경로가 해가 유망하지 않다고 판단되면 이전 노드(부모 노드)로 되돌아가 다시 해를 찾아가는 기법
- 완전탐색에서 불필요한 분기(Branch)를 가지치기(Pruning)

10. DFS와 Backtracking 차이

- DFS는 모든 경로를 추적하지만, 백트래킹은 노드의 유망성을 따져 가지치기를 통해 불필요한 경로를 차단하기 때문에 모든 경로를 추적하지 않음
- 시간 복잡도에서 차이가 생김

11. Dijkstra Algorithom이란?

- 하나의 정점에서 다른 모든 정점까지의 최단 경로를 구하는 문제
- 간선들은 모두 양의 간선들을 가져야 하며, 기본 로직은 첫 정점을 기준으로 연결되어 있는 정점들을 추가해가며, 최단 거리를 갱신하고, 정점을 잇기 전까지는 시작점을 제외한 정점들은 모두 무한대 값

12. Two Pointers Algorithm이란?

- 1차원 배열이 있고 이 배열에서 각자 다른 원소를 가리키고 있는 2개의 포인터를 조작해 문제를 해결하는 알고리즘
- 직관적으로 O(n^2) 이상으로 해결해야 하는 문제를 O(n)에 해결
