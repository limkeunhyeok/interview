# 휴머스온 면접 준비

## 자료구조

> 실무에서는 자료구조를 직접 구현하진 않고 검증된 라이브러리를 가져다 쓴다. 하지만 잘 가져다 쓰려면 각각의 자료구조가 무엇인지, 특성은 어떤지 이해해야 한다. 그림의 형태로 자료구조를 이해하고 설명할 수 있을 정도만 되어도 큰 의미가 있지만, 코드 레벨에서 자료구조의 이해와 구현한 경험이 있다면 자료구조를 보는 깊이가 달라진다.

- 배열(Array): 연관된 데이터를 모아서 통으로 관리하기 위해서 사용하는 데이터 타입
- 연결 리스트(Linked List): 각 노드가 데이터와 포인터를 가지고 연결되어 데이터를 저장하는 자료구조
- 스택(Stack): 한 쪽 끝에서만 데이터를 넣고 뺄 수 있는 LIFO(Last In First Out) 형식으로 저장하는 자료구조
- 큐(Queue): 먼저 집어 넣은 데이터가 먼저 나오는 FIFO(First In First Out)구조로 저장하는 자료구조
- 트리(Tree): 계층적 관계를 표현하는 비선형 자료구조
  - 이진 트리(Binary Tree): 좌측엔 부모 노드보다 작은 값, 우측엔 자식 노드보다 작은 값을 가지는 2개의 자식노드를 갖는 트리
- 힙(heap): 완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조
  - 이진 탐색 트리는 탐색을 위한 구조라면 힙은 최대/최소 값 검색을 위한 구조
- 그래프(Graph): 정점(Vertex)과 그 정점들을 연결하는 간선(Edge)로 구성된 자료구조
- 해쉬 테이블(Hash Table): 해쉬 함수(Hash Function)을 통해 키를 값에 매핑하는 자료구조
- 그래프 vs 트리
  - 사이클
  - 부모-자식 관계
  - 네트워크 모델(그래프), 계층 모델(트리)

## 알고리즘

> 좋은 개발자란 많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력 즉, 문제 해결 능력이 뛰어난 개발자를 말한다. 알고리즘은 문제 해결 기술을 연마하기 가장 좋은 방법이며 스스로 문제를 어떤 방식으로 해결하는지 의식하고 어느 부분이 부족한지, 어떤 부분을 개선해야 하는지 파악해야 한다.

- Brute Force: 컴퓨터의 빠른 계산 능력을 이용해 가능한 경우의 수를 일일이 나열하면서 답을 찾는 방법
- Divide & Conquer: 주어진 문제를 둘 이상의 부분 문제로 나눈 뒤, 각 문제에 대한 답을 재귀 호출을 통해 계산하고, 각 부분 문제의 답으로부터 전체 문제의 답을 계산하는 방법
- Dynamic Programming: 큰 의미에서는 분할 정복과 같은 접근 방식으로, 여러번 중복되는 부분 문제의 계산 결과를 저장하고 결과를 재활용하여 속도를 향상시키는 방법
- Greedy: 각 단계마다 지금 당장 가장 좋은 방법만 선택하는 방법으로, 지금의 선택이 앞으로 남은 선택들에 어떤 영향을 끼칠지는 고려하지 않음

## 운영 체제

### 1. 프로세스 vs 스레드

- 프로그램이란 어떤 작업을 위해 실행할 수 있는 파일

#### 1-1 프로세스(Process)란

![프로세스](https://user-images.githubusercontent.com/38815618/95097975-10d09e00-0769-11eb-9b5c-0fba768f2bbd.png)

- 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
- 메모리에 올라와 실행중인 프로그램의 인스턴스
- 운영체제로부터 시스템 자원을 할당받는 작업의 단위
- 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당

#### 1-2 스레드(Thread)란

![쓰레드](https://user-images.githubusercontent.com/38815618/95098003-1928d900-0769-11eb-9824-9a200c4325ee.png)

- 프로세스 내에서 실행되는 여러 흐름의 단위
- 프로세스의 특정한 수행 경로
- 프로세스가 할당받은 자원을 이용하는 실행의 단위
- 스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유

#### 1-3 멀티 프로세스 vs 멀티 스레드

> 별개의 프로그램이라면 독립적인 프로세스를 구성해야겠지만, 서로 관련된 기능은 멀티 스레드로 구현하는 것이 좋다.

![멀티쓰레드](https://user-images.githubusercontent.com/38815618/95097993-162de880-0769-11eb-8121-f666fb62a29a.png)

- 멀티 스레드 이점
    1. 자원의 효율성 증대
    2. 처리 비용 감소 및 응답 시간 단축

### 2. 스케줄러

> 프로세스들이 작업을 수행하려면 프로세스 스케줄러로 CPU를 할당받아야 한다. 이러한 할당 작업은 운영체제로 구현되며 CPU들이 언제, 어느 프로세스에게 배당되는지 결정하는 작업을 프로세스 스케줄링이라고 한다.

- 스케줄링 목적과 기준
  - 공정한 스케줄링
  - 처리량 극대화
  - 응답 시간 최소화
  - 반환 시간 예측 가능
  - 균형있는 자원 사용
  - 응답 시간과 자원 이용 간의 조화
  - 실행의 무한 연기 배제
  - 우선순위제를 실시
  - 바람직한 동작을 보이는 프로세스에게 더 좋은 서비스를 제공

#### 2-1 선점(Preemptive)

> 선점은 한 프로세스가 CPU를 차지하고 있을 때 다른 프로세스가 현재 프로세스를 중지시키고 자신이 CPU를 차지할 수 있을 때를 가리킨다.

- 라운드 로빈(Round robin) 스케줄링: FCFS로 프로세스들이 내보내지며 각 프로세스는 같은 크기의 CPU 시간을 할당
- SRT(Shorest Remaining Time) 스케줄링: SJF 스케줄링과 마찬가지로 새로 도착한 프로세스를 포함하여 처리가 완료
  - 준비 큐에 있는 프로세스들 중 가장 짧은 시간이 소요된다고 판단되는 프로세스를 먼저 수행
- 다단계 큐(Multi Level Queue) 스케줄링: 작업들을 여러 종류의 그룹으로 나누어 여러 개의 큐를 이용하는 스케줄링 기법
- 다단계 피드백 큐(Multilevel Feedback Queue) 스케줄링: 입출력 위주와 CPU 위주인 프로세스의 특성에 따라 서로 다른 CPU의 타임 슬라이스를 부여

#### 2-2 비선점(non-preemptive)

> 비선점은 한 프로세스가 CPU를 할당받으면 다른 프로세스는 CPU를 그 프로세스로부터 뺏을 수 없을 때를 가리킨다.

- 우선순위 스케줄링: 각 프로세스에게 우선순위를 부여하여 순위가 높은 순서대로 처리하는 방법
- 기한부 스케줄링: 작업들이 명시된 시간이나 기한 내에 완료되게 계획하여 처리하는 방법
- FCFS(First Come First Service) 스케줄링: 가장 간단한 방법으로, 프로세스들은 대기 큐에 도착한 순서에 따라 CPU를 할당
- SJF(Shortest Job First) 스케줄링: 준비 큐에서 기다리는 작업 중이던, 큐에서 기다리는 작업 중이던, 수행 시간이 가장 짧다고 판단되는 것을 먼저 수행하는 방법
- HRN(Highest Response ratio Next) 스케줄링: SJF의 약점, 특히 긴 작업과 짧은 작업 간의 지나친 불평등을 어느 정도 보완한 기법

![스케줄링](https://user-images.githubusercontent.com/38815618/95097999-18904280-0769-11eb-9b34-9c086f3a71e9.png)

### 3. Thread-safe

- 멀티스레드 환경에서 여러 스레드가 동시에 하나의 객체 및 변수(공유 자원)에 접근할 때, 의도한 대로 동작하는 것
- Thread-safe하기 위해서는 공유 자원에 접근하는 임계영역(critical section)을 동기화 기법으로 제어해야 함
- 동기화 기법: Mutex, Semaphore
- Reentrant: 재진입성이라는 의미로, 어떤 함수가 Reentrant하다는 것은 여러 스레드가 동시에 접근해도 언제나 같은 실행 결과를 보장한다는 의미

### 4. 뮤텍스(Mutex) vs 세마포어(Semaphore)

- 임계영역(critical section): 공유 자원에 접근하는 부분

#### 4-1 뮤텍스

- 공유된 자원의 데이터를 여러 스레드가 접근하는 것을 막는 것
- 상호배제라고도 하며, Critical Section을 가진 스레드의 Running time이 서로 겹치지 않도록 각각 단독으로 실행하게 하는 기술

#### 4-2 세마포어

- 공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는 것
- 리소스 상태를 나타내는 간단한 카운터이며, 이 값을 통해 접근을 제어

#### 4-3 차이

1. 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없다.
2. 세마포어는 소유할 수 없지만, 뮤텍스는 소유가 가능하며 소유주가 이에 대한 책임을 진다.
3. 뮤텍스는 뮤텍스를 소유하고 있는 쓰레드가 해당 뮤텍스를 해제할 수 있지만, 세마포어는 해당 세마포어를 소유하지 않는 쓰레드가 세마포어를 해제할 수 있다.

### 5. 교착 상태

- 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태
- 교착 상태 발생의 4가지 조건
  - 상호 배제 조건
  - 점유와 대기 조건
  - 비선점 조건
  - 환형 대기 조건
- 교착 상태는 4가지 조건을 제거함으로써 예방

### 6. 메모리 구조

> 프로그램이 실행되기 위해서는 먼저 프로그램이 메모리에 로드되어야 하며, 프로그램에서 사용되는 변수들을 저장할 메모리도 필요하다.

![메모리](https://user-images.githubusercontent.com/38815618/95097998-17f7ac00-0769-11eb-9026-f2dda5e165bb.png)

1. 코드 영역
    - 실행할 프로그램의 코드가 저장되는 영역으로 텍스트(code) 영역이라고도 부름
2. 데이터 영역
    - 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역
3. 스택 영역
    - 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역
    - 스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸
4. 힙 영역
    - 사용자가 직접 관리할 수 있는 영역
    - 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됨

### 7. 메모리 관리

> 각각의 프로세스 는 독립된 메모리 공간을 갖고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려있으며, 운영체제 만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않는다.

- Swapping: 메모리의 관리를 위해 사용되는 기법으로 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치로 내보내고 다른 프로세스의 메모리를 불러 들임
- 단편화 (Fragmentation): 프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면, 프로세스들이 차지하는 메모리 틈 사이에 사용 하지 못할 만큼의 작은 자유공간들이 늘어나는 것
  - 내부 단편화(internal fragmentation): 하나의 분할에 작업을 할당하고 남은 공간
  - 외부 단편화(external fragmentation): 대기 중인 작업에게는 분할이 너무 적어 분할 전체가 공간으로 있을 때의 상태

#### 7-1 페이징(Paging)

- 컴퓨터가 메인 메모리에서 사용하기 위해 2차 기억 장치[a]로부터 데이터를 저장하고 검색하는 메모리 관리 기법
- 가상기억장치를 모두 같은 크기의 블록으로 편성하여 운용하는 기법
  - 이때의 일정한 크기를 가진 블록을 페이지(page)라고 함
- 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없앰
- 내부 단편화 문제의 비중이 늘어남

#### 7-2 세그멘테이션(Segmentation)

- 페이징은 프로세스를 물리적으로 일정한 크기로 나눠서 메모리에 할당하는 것이라면, 세그멘테이션은 프로세스를 논리적 내용을 기반으로 나눠서 메모리에 배치하는 것
- 세그멘테이션의 가상 주소는 (세그먼트 번호, 변위)의 순서쌍으로 구성

### 8. 가상 메모리(Virtual Memory)

> 다중 프로그래밍을 실현하기 위해서는 많은 프로세스들을 동시에 메모리에 올려두어야 한다. 가상메모리는 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법 이며, 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있다.

- 사용 장점
  - 물리 메모리 크기에 제약받지 않음
  - 더 많은 프로그램을 동시에 실행할 수 있으며, 이에 따라 응답시간은 유지되고, CPU 이용률과 처리율은 높아짐
  - swap에 필요한 입출력이 줄어들기 때문에 프로그램들이 빠르게 실행
- 가상 메모리는 가상 주소 공간을 제공하며, 프로세스 간 페이지를 공유

#### 8-1 반입 정책(Fetch Strategic)

- 적재할 프로그램이나 자료를 언제 주기억 장치로 가져올 것인가를 결정하는 문제
- 요구 페이징(Demand Paging): 요구 페이징은 어떤 프로그램이나 자료가 실행되거나 참조되는 시점에 특정 페이지나 세그먼트를 주기억 장치로 이동시키는 것
  - 요구가 있을 때 교체하며, 동시에 모든 페이지를 교체하지 않음
- 예상 페이징(anticipatory paging): 현 프로그램 수행 중에 앞으로 CPU가 참조할 가능성이 높은 자료 또는 프로그램을 예상하여 운영 체제가 미리 주기억 장치로 옮기는 방법

#### 8-2 교체 정책(Replacement Strategy)

- CPU가 참고하는 페이지를 주기억 장치에 적재하기 위해서, 어떤 페이지를 주기억 장치로부터 제거할 것인가를 결정하는 정책
- 최적 교체(Optimal Replacement): 앞으로 가장 오랜 기간 동안 사용되지 않을 페이지를 교체시키는 것
- 무작위 페이지 교체(Random Page Replacement): 특별한 사용자들에게 차이를 두지 않고 페이지를 교체하는 기법으로, 교체할 페이지를 무작위로 선택
- FIFO(First In First Out): 각 페이지가 주기억 장치로 들어올 때마다 time-stamp를 찍어 그 시간을 기억하고 있다가 페이지가 교체될 필요가 있을 때 가장 먼저 주기억 장치에 들어와 있는 페이지와 교체시키는 방법
- 2차 기회(Second chance) 교체: 모든 페이지들의 참조 비트를 두어 참조 비트가 1이면 피드백시켜 유지하고 0인 페이지만 교체하는 방법
- LRU(Least Recently Used): 가장 널리 사용하는 방법으로, 한 프로세스에서 사용되는 각 페이지마다 카운터를 두어 현 시점에서 가장 오랫동안 사용되지 않은 페이지를 제거하는 방법
- LFU(Least Frequence Used): 사용 빈도가 가장 낮은 페이지 즉, 호출된 횟수가 가장 적은 페이지를 교체하는 방법
- NUR(Not Used Recently): LRU 교체의 단점인 시간 오버헤드를 해결하기 위한 방법으로, 최근에 사용되지 않은 페이지를 교체하는 것으로써 2개의 비트를 둠

## 데이터베이스

> 데이터베이스가 존재하기 이전에는 파일 시스템을 이용하여 데이터를 관리하였다. 데이터를 각각의 파일 단위로 저장하며 이러한 일들을 처리하기 위한 독립적인 애플리케이션과 상호 연동이 되어야 한다. 이 때의 문제점은 데이터 종속성 문제와 중복성, 데이터 무결성이다.

### 1. 개념

- 데이터베이스란 어느 한 조직에서 업무 처리를 위해 다수의 응용 시스템 혹은 다수의 사용 자들이 공용으로 사용하기 위해 통합/저장된 운영 데이터
- 통합된 데이터(Integrated Data)
- 저장된 데이터(Stored Data)
- 공용 데이터(Shared Data)
- 운영 데이터(Operational Data)

#### 1-1 DBMS

- 파일 시스템의 문제점인 데이터의 중복성과 종속성 등의 문제를 최소화하기 위해 등장하였으며, 사용자와 데이터베이스 간의 중계 역활
- 데이터베이스의 내용을 정의하고 조작, 제어할 수 있도록 함으로써 모든 사용자나 응용 프로그램들이 데이터베이스를 공유할 수 있도록 관리/운영해 주는 소프트웨어 시스템

#### 1-2 스키마(Schema)

- 데이터베이스의 전체적인 구조와 제약조건에 대한 명세를 기술/정의한 것
- 내부 스키마(Internal Schema): 물리적 저장 장치 관점에서 본 데이터베이스의 물리적 구조
- 개념 스키마(Conceptual Schema): 논리적 관점에서 본 전체적인 데이터 구조
- 외부 스키마(External Schema): 전체 데이터 중 사용자가 사용하는 한 부분에서 본 논리적 구조를 말하며, 서브 스키마라고도 함

### 2. 특징

- 계속적인 변화(Continuous Evolution)
- 동시 공유(Concurrent Sharing)
- 실시간 접근성(Real-Time Accessibility)
- 내용에 의한 참조(Contents Reference)
- 데이터 중복의 최소화(Redundancy Minimi
- 구성요소
  - 개체(Entity)
  - 속성(Attribute)
  - 관계(Relationship)

### 3. Query문

#### 3-1 SQL 정의어(DDL: Data Definition Language)

- 관계 데이터베이스에서 사용될 테이블, 스키마, 도메인, 인덱스, 뷰 등을 정의(생성)하거나 수정/제거하기 위해 사용되는 언어
- CREATE
  1. 테이블 정의
  2. 스키마 정의
  3. 도메인 정의
  4. 인덱스 정의
- ALTER
- DROP

#### 3-2 SQL 조작어(DML: Data Manipulation Language)

- 데이터베이스 내의 자료를 실제 사용자가 이용하기 위한 언어로, 데이터의 검색, 삽입, 수정, 삭제를 위해 사용
- SELECT: `SELECT 속성 FROM 테이블 [WHERE 조건] [GROUP BY 그룹] [ORDER BY 정렬]`
- INSERT: `INSERT INTO 테이블 VALUE (값 ...)`
- UPDATE: `UPDATE 테이블 SET (속성 = 변경값) [WHERE 조건]`
- DELETE: `DELETE FROM 테이블 [WHERE 조건]`

#### 3-3 SQL 제어어(DCL: Data Control Language)

- 관리자가 데이터의 보안, 무결성 유지, 병행제어, 회복 등을 하기 위해 사용하는 언어
- COMMIT: 연산 유지
- ROLLBACK: 연산 취소
- GRANT: 권한 부여
- REVOKE: 권한 부여 취소

### 4. 데이터베이스 성능

> 데이터베이스의 성능 이슈는 디스크 I/O 를 어떻게 줄이느냐이며, 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다고 볼 수 있다. 따라서 순차 I/O 가 랜덤 I/O 보다 빠를 수 밖에 없다. 하지만 현실에서는 대부분의 I/O 작업이 랜덤 I/O 이며, 랜덤 I/O를 순차 I/O로 바꿔서 실행하기 위해 데이터베이스 쿼리 튜닝은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.

### 5. 정규화

> 한 릴레이션에 여러 엔티티의 애트리뷰트들을 혼합하게 되면 정보가 중복 저장되며, 저장 공간을 낭비하게 된다. 또 중복된 정보로 인해 갱신 이상이 발생하게 된다. 동일한 정보를 한 릴레이션에는 변경하고, 나머지 릴레이션에서는 변경하지 않은 경우 어느 것이 정확한지 알 수 없게 되는 것이다. 이러한 문제를 해결하기 위해 정규화 과정을 거치는 것이다.

- 정규화는 관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업

#### 5-1 이상 현상

- 이상 현상은 데이터베이스의 논리적 설계 시 하나의 릴레이션에 많은 속성들이 존재하여, 데이터의 중복과 종속으로 인해 발생되는 문제점
- 삭제 이상, 삽입 이상, 갱신 이상

### 6. 트랜잭션(Transaction)

- 데이터베이스 내에서 한꺼번에 모두 수행되어야 할 연산들의 집합
- 하나의 작업 처리를 위한 논리적 작업 단위
- 작업의 완전성을 보장

#### 6-1 트랜잭션 특성 ACID

- 원자성(Atomicity): 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 함
- 일관성(Consistency): 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환함
- 격리성(Isolation): 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없음
- 영속성(Durability): 성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영되어야 함

### 7. NoSQL

- 대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소

## 네트워크

### 1. HTTP

### 2. DNS

### 3. TCP와 UDP

### 4. 웹 통신 과정

## 객체 지향 프로그래밍(Object Oriented Programming)

- 프로그래밍 패러다임 중 하나로, 프로그램을 객체 단위로 나누어, 각각의 객체들 간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법
- 4가지 특징
  - 추상화(Abstraction): 객체들이 가진 공통의 특성을 파악하고 불필요한 특성을 제거하는 과정(모델링)
  - 캡슐화(Encapsulation): 객체의 속성과 행위를 하나로 묶고 실제 구현된 내용 일부를 외부에 감추어 은닉하는 것, 정보 은닉(객체의 오용, 오염 방지)
  - 상속(Inheritance): 객체의 필드와 메소드를 다른 객체가 물려 받을 수 있는 것(재사용 + 확장)
  - 다형성(Polymorphism): 다형성이란 동일한 조작방법으로 메소드를 동작시키지만 각자 다른 방식으로 동작하는 것

## RESTful API

## Test-Driven Development

## MVC 패턴

## Waterfall method

## eXtreme Programming

## Spiral Method

## Agile method/Iterative Method

## Prototype Method

## GIT

## VM

## GC

## Docker

## Kafka

## 빌드 과정

## 보안

### 1. XSS

### 2. SQL Injection

### 3. DDos

### 4. Oauth
