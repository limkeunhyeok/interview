# 운영체제

> 아무리 개념적으로 완벽하더라도 실제 그것이 어떻게 구현되었는지 모른다면, 언제 무너질지 모르는 바닷가의 모래성과 같다. 무너지지 않으려면 운영체제라는 기본 뼈대가 바탕이 되어야 한다. 또한, 응용 프로그램을 효율적으로 짜는 것은 그 하부의 시스템이 어떻게 구현되어 있는가에 의존한다. 효과적인(최적화된) 코드를 만든다는 것은, 자신이 하고자 하는 일을 가장 하부 시스템이 가장 잘 지원할 수 있는 형태로 만들 때 가능하다.

1. Process란?

- 메모리에 올라와 실행중인 프로그램의 인스턴스
- 운영체제로부터 시스템 자원을 할당받는 작업의 단위
- 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당

2. PCB(Process Control Block)란?

- 프로세스를 관리하는데 사용하는 운영체제의 자료구조
- 운영 체제가 프로세스를 표현한 것
- 프로세스의 생성과 동시에 고유한 PCB를 생성하고, 프로세스가 완료되면 PCB는 제거

3. Thread란?

- 프로세스 내에서 실행되는 여러 흐름의 단위
- 프로세스가 할당받은 자원을 이용하는 실행의 단위
- 스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유

4. 쓰레드에서 스택의 역활은?

- 스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간
- 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이며 각각의 쓰레드가 독립적으로 실행이 가능하다는 것

5. 멀티 쓰레드의 장점

- 자원의 효율성 증대
- 처리 비용 감소 및 응답 시간 단축

6. 멀티 쓰레드 문제점

- 공유 자원에 동시에 접근하는 일이 생겨 동기화 작업이 필요
- 동기화를 통해 작업 처리 순서를 컨트롤하는 과정에서 병목현상이 발생하여 성능이 저하될 수 있음

7. 멀티 프로세스 vs 멀티 쓰레드

- 별개의 프로그램이라면 독립적인 프로세스를 구성
- 서로 관련된 기능은 멀티 스레드로 구현

8. 스케줄링이란?

- CPU들이 언제, 어느 프로세스에게 배당되는지 결정하는 작업

9. 스케줄링을 하는 이유

- 처리량 극대화
- 균형있는 자원 사용
- 응답 시간 최소화

10. 선점(Preemptive) 기법이란?

- 한 프로세스가 CPU를 차지하고 있을 때 다른 프로세스가 현재 프로세스를 중지시키고 자신이 CPU를 차지하는 스케줄링 기법

11. 비선점(non-preemptive) 기법이란?

- 한 프로세스가 CPU를 할당받아 실행중이라면 다른 프로세스들이 CPU를 강제적으로 뺏을 수 없는 스케줄링 기법

12. FCFS(First Come First Served) 또는 FIFO(First In First Out)란?

- 먼저 온 프로세스를 먼저 처리하는 방식
- 비선점형 스케줄링
- 수행 시간이 긴 프로세스가 먼저 도달한다면 효율성이 떨어짐

13. SJF(Shortest-Job-First)란?

- 수행 시간이 적은 프로세스를 먼저 처리하는 방식
- 비선점형 스케줄링
- 수행 시간이 긴 프로세스는 거의 영원히 CPU를 할당받을 수 없음

14. SRT(Shortest Remaining Time)란?

- 새로 도착한 프로세스의 실행 시간과 현재 실행중인 프로세스의 남은 시간을 비교하여 수행시간이 적은 프로세스에 CPU를 할당하는 방식
- 선점형 스케줄링
- 새로운 프로세스가 도달할 때마다 스케줄링을 다시하기 때문에 CPU 사용시간을 측정할 수가 없음

15. Priority Scheduling이란?

- 대기중인 각 프로세스마다 우선 순위를 부여하여, 우선 순위가 가장 높은 프로세스에 먼저 CPU를 할당하는 방식
- 선점형 스케줄링 방식은 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU를 선점
- 비선점형 스케줄링 방식은 더 높은 우선순위의 프로세스가 도착하면 Ready Queue의 Head에 삽입
- 실행 준비는 되어있으나 CPU 를 사용못하는 프로세스를 CPU 가 무기한 대기하는 상태가 발생할 수 있음

16. Round Robin이란?

- 현대적인 CPU 스케줄링으로, FCFS로 프로세스들이 내보내지며 각 프로세스는 같은 크기의 CPU 시간을 할당하는 방식
- RR은 CPU 사용시간이 랜덤한 프로세스들이 섞여있을 경우에 효율적

17. 동기와 비동기의 차이

- 동기는 순차적으로 실행되는 것이며 비동기는 비순차적으로 실행되는 것

18. Critical Section이란?

- 어느 한 시점에서 둘 이상의 프로세스가 동시에 자원 또는 데이터를 사용하도록 지정된 공유 영역을 의미
- 공유 자원에 동시에 접근하는 작업을 실행하는 코드 영역

19. Thread Safe란?

- 멀티스레드 환경에서 여러 스레드가 동시에 하나의 객체 및 변수(공유 자원)에 접근할 때, 의도한 대로 동작하는 것
- Thread-safe하기 위해서는 공유 자원에 접근하는 임계영역(critical section)을 동기화 기법으로 제어해야 함
- Reentrant: 재진입성이라는 의미로, 어떤 함수가 Reentrant하다는 것은 여러 스레드가 동시에 접근해도 언제나 같은 실행 결과를 보장한다는 의미

20. Mutex란?

- 공유된 자원의 데이터를 여러 스레드가 접근하는 것을 막는 것
- 상호배제라고도 하며, Critical Section을 가진 스레드의 Running time이 서로 겹치지 않도록 각각 단독으로 실행하게 하는 기술
- Lock이라고도 하며, Critical Section에 진입하는 프로세스는 Lock을 획득하고 Critical Section을 빠져나올 때, Lock을 방출함으로써 동시에 접근이 되지 않도록 함

21. Semaphore란?

- 공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는 것
- 리소스 상태를 나타내는 간단한 카운터이며, 이 값을 통해 접근을 제어

22. 세마포어와 뮤텍스의 차이

- 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없음
- 세마포어는 소유할 수 없지만, 뮤텍스는 소유가 가능하며 소유주가 이에 대한 책임을 짐
- 뮤텍스는 뮤텍스를 소유하고 있는 쓰레드가 해당 뮤텍스를 해제할 수 있지만, 세마포어는 해당 세마포어를 소유하지 않는 쓰레드가 세마포어를 해제

23. 교착 상태란?

- 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태

24. 모니터란?

- 고급 언어의 설계 구조물로서, 개발자의 코드를 상호배제 하게끔 만든 추상화된 데이터 형태
- 공유자원에 접근하기 위한 키 획득과 자원 사용 후 해제를 모두 처리

25. 상호 배제(Mutual Exclusion) 조건이란?

- 한번에 한개의 프로세스만이 공유 자원을 사용할 수 있어야 함

26. 점유와 대기(Hold and Wait) 조건이란?

- 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 이해 대기하는 프로세스가 존재

27. 비선점(Non-preemption) 조건이란?

- 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음

28. 환형 대기(Circular Wait) 조건이란?

- 공유자원과 공유자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 함

29. 예방기법(Prevention)이란?

- 교착상태가 발생하지 않도록 사전에 시스템을 제어하는 방법으로 교착상태 발생의 네 가지 조건 중에서 어느 하나를 제거

30. 회피 기법(Avoidance)이란?

- 교착상태가 발생할 가능성을 배제하지 않고 교착상태가 발생하면 적절히 피해나가는 방법으로, 주로 은행원 알고리즘(Banker's Algorithm)이 사용

31. 은행원 알고리즘이란?

- 은행원 알고리즘은 다익스트라가 제안한 기법으로, 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래한 기법

32. 발견 기법(Detection)이란?

- 시스템에 교착상태가 발생했는지 점검하여 교착상태에 있는 프로세스와 자원을 발견하는 것

33. 회복 기법(Recovery)이란?

- 교착상태를 일으킨 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것

34. 메모리 구조

- 코드 영역: 실행할 프로그램의 코드가 저장되는 영역으로 텍스트(code) 영역이라고도 부름
- 데이터 영역: 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역
- 스택 영역: 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역, 스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸
- 힙 영역: 사용자가 직접 관리할 수 있는 영역, 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됨

35. Swapping이란?

- 메모리의 관리를 위해 사용되는 기법으로 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치로 내보내고 다른 프로세스의 메모리를 불러 들임

36. 단편화(Fragmentation)란?

- 프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면, 프로세스들이 차지하는 메모리 틈 사이에 사용 하지 못할 만큼의 작은 자유공간들이 늘어나는 것

37. 내부 단편화(internal fragmentation)란?

- 하나의 분할된 공간에 작업을 할당하고 남은 공간

38. 외부 단편화(external fragmentation)란?

- 대기 중인 작업에게는 분할 공간이 너무 작어 분할 전체가 공간으로 있을 때의 상태

39. 페이징(Paging)이란?

- 컴퓨터가 메인 메모리를 사용하기 위해 2차 기억 장치[a]로부터 데이터를 저장하고 검색하는 메모리 관리 기법
- 가상기억장치를 모두 같은 크기의 블록으로 편성하여 운용하는 기법
- 이때의 일정한 크기를 가진 블록을 페이지(page)라고 함
- 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없앰
- 내부 단편화 문제의 비중이 늘어남

40. 세그멘테이션(Segmentation)

- 페이징은 프로세스를 물리적으로 일정한 크기로 나눠서 메모리에 할당하는 것이라면, 세그멘테이션은 프로세스를 논리적 내용을 기반으로 나눠서 메모리에 배치하는 것
- 세그멘테이션의 가상 주소는 (세그먼트 번호, 변위)의 순서쌍으로 구성

41. 가상 메모리란?

- 기존에 실행되는 코드의 전부를 물리 메모리에 존재시켜야 했고, 메모리 용량보다 큰 프로그램은 실행시킬 수 없었음
- 가상메모리는 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법 이며, 프로그램이 물리 메모리보다 커도 됨

42. Demand Paging(요구 페이징)이란?

- 프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략
- 한 번도 접근되지 않은 페이지는 물리 메모리에 적재되지 않음
- 사용되지 않을 페이지를 가져오는 시간낭비와 메모리 낭비를 줄일 수 있음

43. 반입 정책(Fetch Strategic)이란?

- 적재할 프로그램이나 자료를 언제 주기억 장치로 가져올 것인가를 결정하는 문제

44. 교체 정책(Replacement Strategy)이란?

- CPU가 참고하는 페이지를 주기억 장치에 적재하기 위해서, 어떤 페이지를 주기억 장치로부터 제거할 것인가를 결정하는 정책

45. 최적 교체(Optimal Replacement)란?

- 앞으로 가장 오랜 기간 동안 사용되지 않을 페이지를 교체시키는 것

46. 무작위 페이지 교체(Random Page Replacement)란?

- 특별한 사용자들에게 차이를 두지 않고 페이지를 교체하는 기법으로, 교체할 페이지를 무작위로 선택

47. FIFO(First In First Out)란?

- 각 페이지가 주기억 장치로 들어올 때마다 time-stamp를 찍어 그 시간을 기억하고 있다가 페이지가 교체될 필요가 있을 때 가장 먼저 주기억 장치에 들어와 있는 페이지와 교체시키는 방법

48. 2차 기회(Second chance) 교체란?

- 모든 페이지들의 참조 비트를 두어 참조 비트가 1이면 피드백시켜 유지하고 0인 페이지만 교체하는 방법

49. LRU(Least Recently Used)란?

- 가장 널리 사용하는 방법으로, 한 프로세스에서 사용되는 각 페이지마다 카운터를 두어 현 시점에서 가장 오랫동안 사용되지 않은 페이지를 제거하는 방법

50. LFU(Least Frequence Used)란?

- 사용 빈도가 가장 낮은 페이지 즉, 호출된 횟수가 가장 적은 페이지를 교체하는 방법

51. NUR(Not Used Recently)란?

- LRU 교체의 단점인 시간 오버헤드를 해결하기 위한 방법으로, 최근에 사용되지 않은 페이지를 교체하는 것으로써 2개의 비트를 둠

52. 캐시(Cache)란?

- 캐시 메모리는 속도가 빠른 장치와 느린 장치간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리
- CPU가 어떤 데이터를 원할 것인가를 어느 정도 예측이 필요

53. 캐시의 지역성 원리란?

- 캐시의 성능은 작은 용량의 캐시 메모리에 CPU가 이후에 참조할, 쓸모 있는 정보가 어느 정도 들어있느냐에 따라 좌우되며, 이 때 적중율(Hit rate)을 극대화 시키기 위해 데이터 지역성(Locality)의 원리를 사용
- 지역성의 전제조건으로 프로그램은 모든 코드나 데이터를 균등하게 Access하지 않음

54. 시간 지역성(Temporal Locality)이란?

- 최근에 참조된 주소의 내용은 곧 다음에 다시 참조되는 특성

55. 공간 지역성(Spatial Locality)이란?

- 대부분의 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성

56. Caching line이란?

- 캐시에 데이터를 저장할 때 특정 자료구조를 사용하여 묶음으로 저장하는 것
- 다양한 주소에 있는 데이터를 사용하므로 빈번하게 사용하는 데이터의 주소는 흩어져 있으며, 캐시에 저장하는 데이터에는 데이터의 메모리 주소 등을 기록해 둔 태그를 달아놓을 필요가 있고, 이러한 태그들의 묶음을 캐싱 라인이라고 함

57. 스래싱(thrashing)이란?

- 너무 자주 페이지 교체가 일어나는 현상을 말하는 것으로, 어떤 프로세스가 계속적으로 페이지 부재가 발생하여 프로세스의 처리 시간보다 페이지 교체 시간이 더 많아지는 현상
