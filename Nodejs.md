# Node.js

1. Node.js란?

- 크롬 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임
  - 런타임은 특정 언어로 만든 프로그램을 실행할 수 있는 환경을 말하며, 노드는 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있게 해줌
  - 기존 자바스크립트 프로그램은 인터넷 브라우저에서만 실행할 수 있었음
- 이벤트 기반, 논블로킹 I/O 모델을 사용해 가볍고 효율적

2. Node.js의 특징

- 자바스크립트 기반
- 싱글 쓰레드
- 이벤트 루프 기반
- 비동기 I/O 처리(Non-Blocking I/O)
- 방대한 모듈 제공(NPM)

3. Node.js의 장단점

- 장점
  - 기존의 프론트앤드 개발자들도 백엔드 개발이 가능하며, 생산성이 높음
  - 싱글 쓰레드 기반의 비동기 I/O 처리로 인한 고성능 및 서버 부하가 적음
  - npm을 통한 다양한 모듈(패키지)을 제공하여 개발속도와 효율성이 크게 향상
- 단점
  - 싱글 쓰레드 모델이기 때문에 하나의 작업 자체가 시간이 많이 걸리면 전체 시스템 성능이 떨어짐
  - 이벤트 기반 비동기방식이라 서버단 로직이 복잡한 경우 콜백지옥에 빠질 수 있음
  - 코드가 수행되어야 코드에 에러가 있는지 알 수 있으며, 에러가 날 경우 프로세스가 내려감

4. Node.js가 어울리는 웹서비스

- 네트워크나 데이터베이스, 디스크 작업 같은 I/O에 특화되어 있어, 개수는 많지만 크기는 작은 데이터를 실시간으로 주고 받는 데 적합
- 실시간 채팅 애플리케이션이나 주식 차트, JSON 데이터를 제공하는 API 서버가 노드를 많이 사용

5. Node.js가 어울리지 않는 웹서비스

- 이미지나 비디오 처리, 대규모 데이터 처리 같이 CPU를 많이 사용하는 작업
- 단일 처리가 오래 걸리는 경우: 싱글 쓰레드이기 때문
- 서버 체크로직이 많은 경우: 비동기방식이기 때문에 CallBack Hell에 빠지지 않기 위해
- 업무 복잡도/난이도가 높은 경우: 에러가 나면 서버가 죽기 때문에 코드 품질 중요

6. 이벤트 기반이란?

- 이벤트 기반(event-driven)이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식
- 이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해두어야 하며, 이것을 이벤트 리스너(event listener)에 콜백(callback) 함수를 등록한다고 표현
- 노드도 이벤트 기반 방식으로 동작하므로 이벤트가 발생하면 이벤트 리스너에 등록해둔 콜백 함수를 호출하며, 발생한 이벤트가 없거나 발생했던 이벤트를 다 처리하면 노드는 다음 이벤트가 발생할 때까지 대기

7. 이벤트 루프란?

- 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당
- 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하므로 루프라고 불림

8. 태스크 큐란?

- 이벤트 발생 후 호출되어야 할 콜백 함수들이 기다리는 공간
- 콜백들이 이벤트 루프가 정한 순서대로 줄을 서 있으므로 콜백 큐라고도 부름

9. 백그라운드란?

- 타이머나 I/O 작업 콜백 또는 이벤트 리스너들이 대기하는 곳

10. 논 블로킹 I/O란?

- 논 블로킹이란  이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행하는 것을 말하며 블로킹이란 이전 작업이 끝나야만 다음 작업을 수행하는 것을 의미

11. 싱글 스레드란?

- 노드를 실행하면 먼저 프로세스가 하나 생성되고 해당 프로세스에서 여러 스레드들이 생성되는데, 이 때 직접 제어할 수 있는 스레드는 하나임
- 노드는 스레드를 늘리는 대신, 프로세스 자체를 복사해 여러 작업을 동시에 처리하는 멀티 프로세싱 방식
  - 바스크립트 언어 자체가 싱글 스레드 특성을 띠고 있기 때문

12. 노드가 싱글 스레드로 동작하지 않는 경우는?

- 스레드풀
  - 노드가 특정 동작을 수행할 때 스스로 멀티 스레드를 사용하며, 암호화, 파일 입출력, 압축 등이 있음
- 워커 스레드
  - 노드 12 버전에서 안정화된 기능으로 직접 다수의 스레드를 다룰 수 있으며, CPU 작업(연산이 많은 작업)이 많은 경우 워커 스레드를 사용

13. 스코프란?

- 변수에 접근할 수 있는 범위
- 전역 스코프(Global Scope)는 전역에 선언되어 어느 곳에서든지 해당 변수에 접근
- 지역 스코프(Local Scope)는 해당 지역에서만 접근할 수 있어 지역을 벗어난 곳에선 접근할 수 없음
- 함수 스코프(Function Scope)는 함수 내에서 선언되어, 함수 안에서만 접근
- 블록 스코프(Block Scope)는 변수를 괄호 안에 const나 let키워드로 선언했을 때, 괄호 안에서만 접근
- 렉시컬 스코프(lexical scoping)는 함수가 다른 함수 안에서 만들어졌고 안쪽 함수(inner function)는 바깥 함수(outer function)의 변수에 접근 가능하며, 바깥 함수는 안쪽 함수의 변수에 접근할 수 없음

14. var, const, let 비교

- var는 함수 스코프를 가지며, if문의 블록과 관계없이 접근
- const, let은 블록 스코프를 가지며, 블록 밖에서는 접근할 수 없음
- const는 재할당이 불가능하며, let은 재할당이 가능

15. 호이스팅이란?

- 변수와 함수 선언문은 선언된 위치에서 코드의 꼭대기로 끌어올려지는 것
- function 키워드와 함께 선언된 함수들은 항상 현재 스코프의 가장 위로 호이스팅
- 함수 표현식으로 작성된 함수들은 현재 스코프의 가장 위로 호이스팅 되지 않음

16. Closure란?

- 독립적인 변수를 가리키는 함수
- 흔히 함수 내에서 함수를 정의하고 사용하면 클로저
- 외부에서 변수에 접근하는 것을 제한
- 사이드 이펙트(side effects)를 제어
  - 사이드 이펙트란 어떤 함수 내에서 자신의 스코프가 아닌 변수들을 제어하는 것

17. 미들웨어란?

- 구조 내에서 중간 처리를 위한 함수
- 요청에 대한 응답을 완수하기 전까지 다양한 일을 처리함
- 요청 - 응답을 주기로 종료
- 먼저 로드되는 미들웨어 함수가 먼저 실행됨

18. REPL이란?

- Read(읽기), Eval(평가), Print(출력), Loop(반복)의 줄임말
- CLI 위에서 작동
- 컴파일 과정없이 즉석에서 코드를 입력해 결과를 바로 알 수 있는 방식

19. 동기와 비동기의 차이는?

- 동기(Synchronous)적 처리: 요청을 보낸 후 해당 요청의 응답을 받아야 다음 동작을 실행하는 방식
- 비동기(Asynchronous)적 처리: 요청을 보낸 후 응답과 관계없이 다음 동작을 실행하는 방식

20. Promise란?

- 프로미스는 자바스크립트 비동기 처리에 사용되는 객체
- 프로미스 3가지 상태
  - Pending(대기): 비동기 처리 로직이 아직 완료되지 않은 상태, 콜백 함수를 선언할 수 있고 인자로 resolve, reject를 받음
  - Fulfilled(이행): 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태
  - Rejected(실패): 비동기 처리가 실패하거나 오류가 발생한 상태

21. async와 await란?

- async와 await는 자바스크립트의 비동기 처리 패턴 중 최근에 나온 문법
- 기존의 콜백 함수와 프로미스의 단점을 보완하고 개발자가 읽기 좋은 코드를 작성하게 도와줌
